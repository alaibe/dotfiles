# Clojure snippets for LuaSnip (SnipMate format)

snippet ns "namespace declaration"
	(ns ${1:namespace-name}
	  ${2:(:require [${3:clojure.string :as str}])})

	$0

snippet defn "function definition"
	(defn ${1:function-name}
	  "${2:docstring}"
	  [${3:args}]
	  ${0:body})

snippet defn- "private function definition"
	(defn- ${1:function-name}
	  "${2:docstring}"
	  [${3:args}]
	  ${0:body})

snippet def "def binding"
	(def ${1:var-name} ${0:value})

snippet let "let binding"
	(let [${1:bindings}]
	  ${0:body})

snippet if "if expression"
	(if ${1:condition}
	  ${2:then}
	  ${0:else})

snippet when "when expression"
	(when ${1:condition}
	  ${0:body})

snippet cond "cond expression"
	(cond
	  ${1:condition} ${2:result}
	  ${3::else} ${0:default})

snippet doseq "doseq loop"
	(doseq [${1:bindings}]
	  ${0:body})

snippet for "for comprehension"
	(for [${1:bindings}]
	  ${0:body})

snippet map "map function"
	(map ${1:function} ${0:collection})

snippet filter "filter function"
	(filter ${1:predicate} ${0:collection})

snippet reduce "reduce function"
	(reduce ${1:function} ${2:initial} ${0:collection})

snippet try "try-catch block"
	(try
	  ${1:body}
	  (catch ${2:Exception} ${3:e}
	    ${0:error-handling}))

snippet test "deftest"
	(deftest ${1:test-name}
	  (testing "${2:test description}"
	    (is (= ${3:expected} ${0:actual}))))

snippet is "test assertion"
	(is (= ${1:expected} ${0:actual}))

snippet spec "clojure.spec definition"
	(s/def ::${1:spec-name} ${0:spec-definition})

snippet fdef "function spec"
	(s/fdef ${1:function-name}
	  :args (s/cat ${2:args-spec})
	  :ret ${3:return-spec})

snippet comment "comment block"
	(comment
	  ${0:code}
	)

snippet pr "println debug"
	(println "${1:debug}: " ${0:value})

snippet ppr "pretty print debug"
	(clojure.pprint/pprint ${0:value})

snippet deps "deps.edn file"
	{:deps {org.clojure/clojure {:mvn/version "${1:1.11.1}"}}
	 :paths ["${2:src}"]
	 :aliases
	 {:dev {:extra-paths ["${3:dev}"]
	        :extra-deps {${4:;; dev dependencies}}}
	  :test {:extra-paths ["${5:test}"]
	         :extra-deps {${6:;; test dependencies}}}}}
	$0

snippet thread "Thread-first macro"
	(-> ${1:data}
	    ${2:(function1)}
	    ${0:(function2)})

snippet thread-last "Thread-last macro"
	(->> ${1:collection}
	     ${2:(filter predicate)}
	     ${0:(map transform)})

snippet as-thread "Thread-as macro"
	(as-> ${1:data} ${2:$}
	  ${3:(function1 $)}
	  ${0:(function2 $ other-arg)})

snippet some-thread "Some-thread macro"
	(some-> ${1:data}
	        ${2:(function1)}
	        ${0:(function2)})

snippet destructure "Destructuring example"
	(let [{:keys [${1:key1 key2}]} ${2:map}
	      [${3:first second}] ${4:vector}]
	  ${0:body})

snippet letfn "letfn local functions"
	(letfn [(${1:helper-fn} [${2:args}]
	          ${3:body})]
	  ${0:main-body})

snippet lazy-seq "Lazy sequence"
	(lazy-seq
	  ${0:sequence-body})

snippet gen-class "gen-class"
	(:gen-class
	 :name ${1:com.example.ClassName}
	 :methods [[${2:methodName} [${3:String}] ${4:String}]])

snippet protocol "Protocol definition"
	(defprotocol ${1:ProtocolName}
	  (${2:method-name} [${3:this args}] "${4:docstring}"))

snippet reify "Reify implementation"
	(reify ${1:Protocol}
	  (${2:method-name} [${3:this args}]
	    ${0:implementation}))

snippet record "Record definition"
	(defrecord ${1:RecordName} [${2:field1 field2}]
	  ${3:Protocol}
	  (${4:method-name} [${5:this args}]
	    ${0:implementation}))

snippet multimethod "Multimethod"
	(defmulti ${1:multi-name} ${2:dispatch-fn})

	(defmethod ${3:multi-name} ${4:dispatch-value}
	  [${5:args}]
	  ${0:implementation})

snippet core-async "Core.async channel"
	(let [${1:ch} (chan)]
	  (go
	    (>! ${2:ch} ${3:value}))
	  (go
	    (let [${4:result} (<! ${5:ch})]
	      ${0:process-result})))

snippet transducer "Transducer"
	(def ${1:xf}
	  (comp
	    (filter ${2:predicate})
	    (map ${3:transform})
	    (take ${4:n})))

	${0:(transduce xf conj [] coll)}

snippet atom-swap "Atom swap"
	(swap! ${1:atom} ${2:update-fn}${0: args})

snippet atom-reset "Atom reset"
	(reset! ${1:atom} ${0:new-value})

snippet ref-dosync "Ref with dosync"
	(dosync
	  (ref-set ${1:ref} ${2:new-value})
	  ${0:more-operations})

snippet agent-send "Agent send"
	(send ${1:agent} ${2:update-fn}${0: args})
